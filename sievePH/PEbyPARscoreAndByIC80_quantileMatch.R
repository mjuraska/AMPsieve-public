rm(list=ls(all=TRUE))

library(tidyverse)

logit <- function(p){
  return(log(p/(1-p)))
}

datDir <- paste0("t:/vaccine/p704/analysis/sieve/adata")
source("t:/vaccine/p704/analysis/sieve/code/common.R")

# 'outDir' contains objects of class summary.sievePH generated by the following two files:
# t:/vaccine/p704/analysis/efficacy/code/sievePH_JuraskaGilbert2013/PEbyIC50andIC80andIIP_sievePH.R
# t:/vaccine/p704/analysis/sieve/code/sievePH_JuraskaGilbert2013/PEbyPARscore_sievePH.R
outDir <- "t:/vaccine/p704/analysis/sieve/code/sievePH_JuraskaGilbert2013/Routput"

variant <- c("mf", "ms", "ls")
trial <- c("704", "703", "704and703")

for (d in 1:length(datFile)){
  for (v in 1:length(variant)){
    # Data management ---------------------------------------------------------
    
    outFile2 <- paste0(trial[d], "_sievePH_PEbyIC80", variant[v], "_MITT_VRC01pooled_placebo.RData")
    load(file.path(outDir, outFile2), verbose=TRUE)
    out2 <- sfit$te
    
    outFile <- paste0(trial[d], "_sievePH_PEbylogitPredProbResIC80_", variant[v], "_MITT_VRC01pooled_placebo.RData")
    load(file.path(outDir, outFile), verbose=TRUE)
    out <- sfit$te
    out$UB2 <- out$LB2 <- out$TE2 <- NA
    
    data <- read.csv(file.path(datDir, datFile[d])) %>%
      # filter(!(hiv1event==1 & (is.na(gmt80mf) | is.na(parscore1.mf))))
      filter(!(hiv1event==1 & is.na(parscore1.mf)))
    
    # transform to the scale on which the mark was analyzed
    gmt80name <- paste0("gmt80", variant[v])
    data$gmt80 <- as.character(data[, gmt80name])
    data$gmt80 <- ifelse(data$gmt80==">100", "100", data$gmt80)
    data$gmt80 <- as.numeric(data$gmt80)

    # right-censor at 10
    data$gmt80 <- pmin(10, data$gmt80)
    
    # the next two lines delete all but one value censored at 10 to stretch PE by measured IC80 across the x-axis
    # idx <- which(data$gmt80mf==10)
    # data$gmt80mf[idx[-1]] <- NA
    
    # analyze the gmt80mf on the log10 scale
    data$gmt80 <- log10(data$gmt80)
    
    # Quantile matching -------------------------------------------------------
    
    Fn <- ecdf(data[, paste0("parscore1.", variant[v])])
    keepPlotting <- TRUE
    for (i in 1:NROW(out)){
      prob <- Fn(out$mark[i])
      # quantile(..., type=1) is the inverse of ecdf()
      q <- quantile(data$gmt80, probs=prob, na.rm=TRUE, type=1)
      
      # only plot the quantile-matched secondary PE curve within the support region of the secondary mark variable
      if (q < max(data$gmt80, na.rm=TRUE) || keepPlotting){
        idx <- which.min(abs(out2$mark - q))
        out[i, "TE2"] <- out2[idx, "TE"]
        out[i, "LB2"] <- out2[idx, "LB"]
        out[i, "UB2"] <- out2[idx, "UB"] 
        
        if (q >= max(data$gmt80, na.rm=TRUE)){ keepPlotting <- FALSE }
      }
    }
    
    save(out, file=file.path(outDir, paste0(trial[d], "_sievePH_compPE_logitPredProbResIC80_IC80_", variant[v], "_MITT_VRC01pooled_placebo.RData")))
  }
}
